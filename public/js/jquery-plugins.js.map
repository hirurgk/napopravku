{"version":3,"sources":["jquery.calendar-widget.js","jquery.inputmask.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jquery-plugins.js","sourcesContent":["(function($) { \n   \n\tfunction calendarWidget(el, params) { \n\t\t\n\t\tvar now   = new Date();\n\t\tvar thismonth = now.getMonth();\n\t\tvar thisyear  = now.getYear() + 1900;\n\t\tvar thisday  = now.getDate();\n\t\t\n\t\tvar opts = {\n\t\t\tmonth: thismonth,\n\t\t\tyear: thisyear\n\t\t};\n\t\t\n\t\t$.extend(opts, params);\n\t\t\n\t\tvar monthNames = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];\n\t\tvar dayNames = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];\n\t\tmonth = i = parseInt(opts.month);\n\t\tyear = parseInt(opts.year);\n\t\t\n\t\tvar m = 0;\n\t\tvar table = '';\n\t\t\n\t\t\t// next month\n\t\t\tif (month == 11) {\n\t\t\t\tvar next_month = '<a href=\"?month=' + 1 + '&amp;year=' + (year + 1) + '\" title=\"' + monthNames[0] + ' ' + (year + 1) + '\">' + monthNames[0] + ' ' + (year + 1) + '</a>';\n\t\t\t} else {\n\t\t\t\tvar next_month = '<a href=\"?month=' + (month + 2) + '&amp;year=' + (year) + '\" title=\"' + monthNames[month + 1] + ' ' + (year) + '\">' + monthNames[month + 1] + ' ' + (year) + '</a>';\n\t\t\t}\n\t\t\t\t\n\t\t\t// previous month\n\t\t\tif (month == 0) {\n\t\t\t\tvar prev_month = '<a href=\"?month=' + 12 + '&amp;year=' + (year - 1) + '\" title=\"' + monthNames[11] + ' ' + (year - 1) + '\">' + monthNames[11] + ' ' + (year - 1) + '</a>';\n\t\t\t} else {\n\t\t\t\tvar prev_month = '<a href=\"?month=' + (month) + '&amp;year=' + (year) + '\" title=\"' + monthNames[month - 1] + ' ' + (year) + '\">' + monthNames[month - 1] + ' ' + (year) + '</a>';\n\t\t\t}\t\t\n\t\t\t\t\n\t\t\ttable += ('<h3 id=\"current-month\">'+monthNames[month]+' '+year+'</h3>');\n\t\t\t// uncomment the following lines if you'd like to display calendar month based on 'month' and 'view' paramaters from the URL\n\t\t\t//table += ('<div class=\"nav-prev\">'+ prev_month +'</div>');\n\t\t\t//table += ('<div class=\"nav-next\">'+ next_month +'</div>');\n\t\t\ttable += ('<table class=\"table table-bordered \" ' +'id=\"table-calendar\" cellspacing=\"0\">');\t\n\t\t\n\t\t\ttable += '<tr>';\n\t\t\t\n\t\t\tfor (d=0; d<7; d++) {\n\t\t\t\ttable += '<th class=\"weekday\">' + dayNames[d] + '</th>';\n\t\t\t}\n\t\t\t\n\t\t\ttable += '</tr>';\n\t\t\n\t\t\tvar days = getDaysInMonth(month,year);\n            var firstDayDate=new Date(year,month,0);\n            var firstDay=firstDayDate.getDay();\n\t\t\t\n\t\t\tvar prev_days = getDaysInMonth(month,year);\n            var firstDayDate=new Date(year,month,0);\n            var firstDay=firstDayDate.getDay();\n\t\t\t\n\t\t\tvar prev_m = month == 0 ? 11 : month-1;\n\t\t\tvar prev_y = prev_m == 11 ? year - 1 : year;\n\t\t\tvar prev_days = getDaysInMonth(prev_m, prev_y);\n\t\t\tfirstDay = (firstDay == 0 && firstDayDate) ? 7 : firstDay;\n\t\n\t\t\tvar i = 0;\n            for (j=0;j<42;j++){\n\t\t      if (year == thisyear && month == thismonth)\n\t\t\t    var oldDay = (j-firstDay) - thisday < 0 ? 'old-day' : '';\n\t\t\t  \n\t\t\t  var strDate = year + '-' + (month+1) + '-' + (j-firstDay+1);\n\t\t\t  \n              if ((j<firstDay)){\n                table += ('<td data-date=\"'+strDate+'\" class=\"other-month '+oldDay+'\"><span class=\"day\">'+ (prev_days-firstDay+j+1) +'</span></td>');\n\t\t\t  } else if ((j>=firstDay+getDaysInMonth(month,year))) {\n\t\t\t\ti = i+1;\n                table += ('<td data-date=\"'+strDate+'\" class=\"other-month '+oldDay+'\"><span class=\"day\">'+ i +'</span></td>');\n              }else{\n                table += ('<td data-date=\"'+strDate+'\" class=\"current-month '+oldDay+' day'+(j-firstDay+1)+'\"><span class=\"day\">'+(j-firstDay+1)+'</span></td>');\n              }\n              if (j%7==6)  table += ('</tr>');\n            }\n\n            table += ('</table>');\n\n\t\tel.html(table);\n\t}\n\t\n\tfunction getDaysInMonth(month,year)  {\n\t\tvar daysInMonth=[31,28,31,30,31,30,31,31,30,31,30,31];\n\t\tif ((month==1)&&(year%4==0)&&((year%100!=0)||(year%400==0))){\n\t\t  return 29;\n\t\t}else{\n\t\t  return daysInMonth[month];\n\t\t}\n\t}\n\t\n\t\n\t// jQuery plugin initialisation\n\t$.fn.calendarWidget = function(params) {    \n\t\tcalendarWidget(this, params);\t\t\n\t\treturn this; \n\t}; \n\n})(jQuery);\n","/**\n* @license Input Mask plugin for jquery\n* http://github.com/RobinHerbots/jquery.inputmask\n* Copyright (c) 2010 - 2012 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 1.2.4\n*/\n\n(function ($) {\n    if ($.fn.inputmask == undefined) {\n        $.inputmask = {\n            //options default\n            defaults: {\n                placeholder: \"_\",\n                optionalmarker: {\n                    start: \"[\",\n                    end: \"]\"\n                },\n                escapeChar: \"\\\\\",\n                mask: null,\n                oncomplete: $.noop, //executes when the mask is complete\n                onincomplete: $.noop, //executes when the mask is incomplete and focus is lost\n                oncleared: $.noop, //executes when the mask is cleared\n                repeat: 0, //repetitions of the mask\n                greedy: true, //true: allocated buffer for the mask and repetitions - false: allocate only if needed\n                autoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor\n                clearMaskOnLostFocus: true,\n                insertMode: true, //insert the input or overwrite the input\n                clearIncomplete: false, //clear the incomplete input on blur\n                aliases: {}, //aliases definitions => see jquery.inputmask.extensions.js\n                onKeyUp: $.noop, //override to implement autocomplete on certain keys for example\n                onKeyDown: $.noop, //override to implement autocomplete on certain keys for example\n                showMaskOnHover: true, //show the mask-placeholder when hovering the empty input\n                onKeyValidation: $.noop, //executes on every key-press with the result of isValid\n                //numeric basic properties\n                numericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)\n                radixPoint: \".\", // | \",\"\n                //numeric basic properties\n                definitions: {\n                    '9': {\n                        validator: \"[0-9]\",\n                        cardinality: 1\n                    },\n                    'a': {\n                        validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451]\",\n                        cardinality: 1\n                    },\n                    '*': {\n                        validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u04510-9]\",\n                        cardinality: 1\n                    }\n                },\n                keyCode: { ALT: 18, BACKSPACE: 8, CAPS_LOCK: 20, COMMA: 188, COMMAND: 91, COMMAND_LEFT: 91, COMMAND_RIGHT: 93, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, MENU: 93, NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108,\n                    NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38, WINDOWS: 91\n                },\n                ignorables: [8, 9, 13, 16, 17, 18, 20, 27, 33, 34, 35, 36, 37, 38, 39, 40, 46, 91, 93, 108]\n            },\n            val: $.fn.val //store the original jquery val function\n        };\n\n        $.fn.inputmask = function (fn, options) {\n            var opts = $.extend(true, {}, $.inputmask.defaults, options);\n            var pasteEvent = isInputEventSupported('paste') ? 'paste' : 'input';\n\n            var iphone = navigator.userAgent.match(/iphone/i) != null;\n            var android = navigator.userAgent.match(/android.*mobile safari.*/i) != null;\n            if (android) {\n                var browser = navigator.userAgent.match(/mobile safari.*/i);\n                var version = parseInt(new RegExp(/[0-9]+/).exec(browser));\n                android = version <= 533;\n            }\n            var caretposCorrection = null;\n\n            if (typeof fn == \"string\") {\n                switch (fn) {\n                    case \"mask\":\n                        //init buffer\n                        var _buffer = getMaskTemplate();\n                        var tests = getTestingChain();\n\n                        return this.each(function () {\n                            mask(this);\n                        });\n                        break;\n                    case \"unmaskedvalue\":\n                        var tests = this.data('inputmask')['tests'];\n                        var _buffer = this.data('inputmask')['_buffer'];\n                        opts.greedy = this.data('inputmask')['greedy'];\n                        opts.repeat = this.data('inputmask')['repeat'];\n                        opts.definitions = this.data('inputmask')['definitions'];\n                        return unmaskedvalue(this);\n                        break;\n                    case \"remove\":\n                        var tests, _buffer;\n                        return this.each(function () {\n                            var $input = $(this), input = this;\n                            setTimeout(function () {\n                                if ($input.data('inputmask')) {\n                                    tests = $input.data('inputmask')['tests'];\n                                    _buffer = $input.data('inputmask')['_buffer'];\n                                    opts.greedy = $input.data('inputmask')['greedy'];\n                                    opts.repeat = $input.data('inputmask')['repeat'];\n                                    opts.definitions = $input.data('inputmask')['definitions'];\n                                    //writeout the unmaskedvalue\n                                    input._valueSet(unmaskedvalue($input, true));\n                                    //clear data\n                                    $input.removeData('inputmask');\n                                    //unbind all events\n                                    $input.unbind(\".inputmask\");\n                                    $input.removeClass('focus.inputmask');\n                                    //restore the value property\n                                    var valueProperty;\n                                    if (Object.getOwnPropertyDescriptor)\n                                        valueProperty = Object.getOwnPropertyDescriptor(input, \"value\");\n                                    if (valueProperty && valueProperty.get) {\n                                        if (input._valueGet) {\n                                            Object.defineProperty(input, \"value\", {\n                                                get: input._valueGet,\n                                                set: input._valueSet\n                                            });\n                                        }\n                                    } else if (document.__lookupGetter__ && input.__lookupGetter__(\"value\")) {\n                                        if (input._valueGet) {\n                                            input.__defineGetter__(\"value\", input._valueGet);\n                                            input.__defineSetter__(\"value\", input._valueSet);\n                                        }\n                                    }\n                                    delete input._valueGet;\n                                    delete input._valueSet;\n                                }\n                            }, 0);\n                        });\n                        break;\n                    case \"getemptymask\": //return the default (empty) mask value, usefull for setting the default value in validation\n                        if (this.data('inputmask'))\n                            return this.data('inputmask')['_buffer'].join('');\n                        else return \"\";\n                    case \"hasMaskedValue\": //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value \n                        return this.data('inputmask') ? !this.data('inputmask')['autoUnmask'] : false;\n                    default:\n                        //check if the fn is an alias\n                        if (!resolveAlias(fn)) {\n                            //maybe fn is a mask so we try\n                            //set mask\n                            opts.mask = fn;\n                        }\n                        //init buffer\n                        var _buffer = getMaskTemplate();\n                        var tests = getTestingChain();\n\n                        return this.each(function () {\n                            mask(this);\n                        });\n\n                        break;\n                }\n            } if (typeof fn == \"object\") {\n                opts = $.extend(true, {}, $.inputmask.defaults, fn);\n                resolveAlias(opts.alias); //resolve aliases\n                //init buffer\n                var _buffer = getMaskTemplate();\n                var tests = getTestingChain();\n\n                return this.each(function () {\n                    mask(this);\n                });\n            }\n\n            //helper     functions\n            function isInputEventSupported(eventName) {\n                var el = document.createElement('input'),\n\t\t        eventName = 'on' + eventName,\n\t\t        isSupported = (eventName in el);\n                if (!isSupported) {\n                    el.setAttribute(eventName, 'return;');\n                    isSupported = typeof el[eventName] == 'function';\n                }\n                el = null;\n                return isSupported;\n            }\n\n            function resolveAlias(aliasStr) {\n                var aliasDefinition = opts.aliases[aliasStr];\n                if (aliasDefinition) {\n                    if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias); //alias is another alias\n                    $.extend(true, opts, aliasDefinition);  //merge alias definition in the options\n                    $.extend(true, opts, options);  //reapply extra given options\n                    return true;\n                }\n                return false;\n            }\n\n            function getMaskTemplate() {\n                var escaped = false, outCount = 0;\n                if (opts.mask.length == 1 && opts.greedy == false) { opts.placeholder = \"\"; } //hide placeholder with single non-greedy mask\n                var singleMask = $.map(opts.mask.split(\"\"), function (element, index) {\n                    var outElem = [];\n                    if (element == opts.escapeChar) {\n                        escaped = true;\n                    }\n                    else if ((element != opts.optionalmarker.start && element != opts.optionalmarker.end) || escaped) {\n                        var maskdef = opts.definitions[element];\n                        if (maskdef && !escaped) {\n                            for (var i = 0; i < maskdef.cardinality; i++) {\n                                outElem.push(getPlaceHolder(outCount + i));\n                            }\n                        } else {\n                            outElem.push(element);\n                            escaped = false;\n                        }\n                        outCount += outElem.length;\n                        return outElem;\n                    }\n                });\n\n                //allocate repetitions\n                var repeatedMask = singleMask.slice();\n                for (var i = 1; i < opts.repeat && opts.greedy; i++) {\n                    repeatedMask = repeatedMask.concat(singleMask.slice());\n                }\n\n                return repeatedMask;\n            }\n\n            //test definition => {fn: RegExp/function, cardinality: int, optionality: bool, newBlockMarker: bool, offset: int, casing: null/upper/lower, def: definitionSymbol}\n            function getTestingChain() {\n                var isOptional = false, escaped = false;\n                var newBlockMarker = false; //indicates wheter the begin/ending of a block should be indicated\n\n                return $.map(opts.mask.split(\"\"), function (element, index) {\n                    var outElem = [];\n\n                    if (element == opts.escapeChar) {\n                        escaped = true;\n                    } else if (element == opts.optionalmarker.start && !escaped) {\n                        isOptional = true;\n                        newBlockMarker = true;\n                    }\n                    else if (element == opts.optionalmarker.end && !escaped) {\n                        isOptional = false;\n                        newBlockMarker = true;\n                    }\n                    else {\n                        var maskdef = opts.definitions[element];\n                        if (maskdef && !escaped) {\n                            var prevalidators = maskdef[\"prevalidator\"], prevalidatorsL = prevalidators ? prevalidators.length : 0;\n                            for (var i = 1; i < maskdef.cardinality; i++) {\n                                var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator[\"validator\"], cardinality = prevalidator[\"cardinality\"];\n                                outElem.push({ fn: validator ? typeof validator == 'string' ? new RegExp(validator) : new function () { this.test = validator; } : new RegExp(\".\"), cardinality: cardinality ? cardinality : 1, optionality: isOptional, newBlockMarker: isOptional == true ? newBlockMarker : false, offset: 0, casing: maskdef[\"casing\"], def: element });\n                                if (isOptional == true) //reset newBlockMarker\n                                    newBlockMarker = false;\n                            }\n                            outElem.push({ fn: maskdef.validator ? typeof maskdef.validator == 'string' ? new RegExp(maskdef.validator) : new function () { this.test = maskdef.validator; } : new RegExp(\".\"), cardinality: maskdef.cardinality, optionality: isOptional, newBlockMarker: newBlockMarker, offset: 0, casing: maskdef[\"casing\"], def: element });\n                        } else {\n                            outElem.push({ fn: null, cardinality: 0, optionality: isOptional, newBlockMarker: newBlockMarker, offset: 0, casing: null, def: element });\n                            escaped = false;\n                        }\n                        //reset newBlockMarker\n                        newBlockMarker = false;\n                        return outElem;\n                    }\n                });\n            }\n\n            function isValid(pos, c, buffer, strict) { //strict true ~ no correction or autofill\n                var result = false;\n                if (pos >= 0 && pos < getMaskLength()) {\n                    var testPos = determineTestPosition(pos), loopend = c ? 1 : 0, chrs = '';\n                    for (var i = tests[testPos].cardinality; i > loopend; i--) {\n                        chrs += getBufferElement(buffer, testPos - (i - 1));\n                    }\n\n                    if (c) {\n                        chrs += c;\n                    }\n                    //return is false or a json object => { pos: ??, c: ??}\n                    result = tests[testPos].fn != null ? tests[testPos].fn.test(chrs, buffer, pos, strict, opts) : false;\n                }\n                setTimeout(opts.onKeyValidation.call(this, result, opts), 0); //extra stuff to execute on keydown\n                return result;\n            }\n\n            function isMask(pos) {\n                var testPos = determineTestPosition(pos);\n                var test = tests[testPos];\n\n                return test != undefined ? test.fn : false;\n            }\n\n            function determineTestPosition(pos) {\n                return pos % tests.length;\n            }\n\n            function getPlaceHolder(pos) {\n                return opts.placeholder.charAt(pos % opts.placeholder.length);\n            }\n\n            function getMaskLength() {\n                var calculatedLength = _buffer.length;\n                if (!opts.greedy && opts.repeat > 1) {\n                    calculatedLength += (_buffer.length * (opts.repeat - 1));\n                }\n                return calculatedLength;\n            }\n\n            //pos: from position\n            function seekNext(buffer, pos) {\n                var maskL = getMaskLength();\n                if (pos >= maskL) return maskL;\n                var position = pos;\n                while (++position < maskL && !isMask(position)) { };\n                return position;\n            }\n            //pos: from position\n            function seekPrevious(buffer, pos) {\n                var position = pos;\n                if (position <= 0) return 0;\n\n                while (--position > 0 && !isMask(position)) { };\n                return position;\n            }\n\n            function setBufferElement(buffer, position, element) {\n                //position = prepareBuffer(buffer, position);\n\n                var test = tests[determineTestPosition(position)];\n                var elem = element;\n                if (elem != undefined) {\n                    switch (test.casing) {\n                        case \"upper\":\n                            elem = element.toUpperCase();\n                            break;\n                        case \"lower\":\n                            elem = element.toLowerCase();\n                            break;\n                    }\n                }\n\n                buffer[position] = elem;\n            }\n            function getBufferElement(buffer, position, autoPrepare) {\n                if (autoPrepare) position = prepareBuffer(buffer, position);\n                return buffer[position];\n            }\n\n            //needed to handle the non-greedy mask repetitions\n            function prepareBuffer(buffer, position, isRTL) {\n                var j;\n                if (isRTL) {\n                    while (position < 0 && buffer.length < getMaskLength()) {\n                        j = _buffer.length - 1;\n                        position = _buffer.length;\n                        while (_buffer[j] !== undefined) {\n                            buffer.unshift(_buffer[j--]);\n                        }\n                    }\n                } else {\n                    while (buffer[position] == undefined && buffer.length < getMaskLength()) {\n                        j = 0;\n                        while (_buffer[j] !== undefined) { //add a new buffer\n                            buffer.push(_buffer[j++]);\n                        }\n                    }\n                }\n\n                return position;\n            }\n\n            function writeBuffer(input, buffer, caretPos) {\n                input._valueSet(buffer.join(''));\n                if (caretPos != undefined) {\n                    if (android) {\n                        setTimeout(function () {\n                            caret(input, caretPos);\n                        }, 100);\n                    }\n                    else caret(input, caretPos);\n                }\n            };\n            function clearBuffer(buffer, start, end) {\n                for (var i = start, maskL = getMaskLength(); i < end && i < maskL; i++) {\n                    setBufferElement(buffer, i, getBufferElement(_buffer.slice(), i));\n                }\n            };\n\n            function setReTargetPlaceHolder(buffer, pos) {\n                var testPos = determineTestPosition(pos);\n                setBufferElement(buffer, pos, getBufferElement(_buffer, testPos));\n            }\n\n            function checkVal(input, buffer, clearInvalid, skipRadixHandling) {\n                var isRTL = $(input).data('inputmask')['isRTL'],\n                    inputValue = truncateInput(input._valueGet(), isRTL).split('');\n\n                if (isRTL) { //align inputValue for RTL/numeric input\n                    var maskL = getMaskLength();\n                    var inputValueRev = inputValue.reverse(); inputValueRev.length = maskL;\n\n                    for (var i = 0; i < maskL; i++) {\n                        var targetPosition = determineTestPosition(maskL - (i + 1));\n                        if (tests[targetPosition].fn == null && inputValueRev[i] != getBufferElement(_buffer, targetPosition)) {\n                            inputValueRev.splice(i, 0, getBufferElement(_buffer, targetPosition));\n                            inputValueRev.length = maskL;\n                        } else {\n                            inputValueRev[i] = inputValueRev[i] || getBufferElement(_buffer, targetPosition);\n                        }\n                    }\n                    inputValue = inputValueRev.reverse();\n                }\n                clearBuffer(buffer, 0, buffer.length);\n                buffer.length = _buffer.length;\n                var lastMatch = -1, checkPosition = -1, np, maskL = getMaskLength(), ivl = inputValue.length, rtlMatch = ivl == 0 ? maskL : -1;\n                for (var i = 0; i < ivl; i++) {\n                    for (var pos = checkPosition + 1; pos < maskL; pos++) {\n                        if (isMask(pos)) {\n                            var c = inputValue[i];\n                            if ((np = isValid(pos, c, buffer, !clearInvalid)) !== false) {\n                                if (np !== true) {\n                                    pos = np.pos || pos; //set new position from isValid\n                                    c = np.c || c; //set new char from isValid\n                                }\n                                setBufferElement(buffer, pos, c);\n                                lastMatch = checkPosition = pos;\n                            } else {\n                                setReTargetPlaceHolder(buffer, pos);\n                                if (c == getPlaceHolder(pos)) {\n                                    checkPosition = pos;\n                                    rtlMatch = pos;\n                                }\n                            }\n                            break;\n                        } else {   //nonmask\n                            setReTargetPlaceHolder(buffer, pos);\n                            if (lastMatch == checkPosition) //once outsync the nonmask cannot be the lastmatch\n                                lastMatch = pos;\n                            checkPosition = pos;\n                            if (inputValue[i] == getBufferElement(buffer, pos))\n                                break;\n                        }\n                    }\n                }\n                //Truncate buffer when using non-greedy masks\n                if (opts.greedy == false) {\n                    var newBuffer = truncateInput(buffer.join(''), isRTL).split('');\n                    while (buffer.length != newBuffer.length) {  //map changes into the original buffer\n                        isRTL ? buffer.shift() : buffer.pop();\n                    }\n                }\n\n                if (clearInvalid) {\n                    writeBuffer(input, buffer);\n                }\n                return isRTL ? (opts.numericInput ? ($.inArray(opts.radixPoint, buffer) != -1 && skipRadixHandling !== true ? $.inArray(opts.radixPoint, buffer) : seekNext(buffer, maskL)) : seekNext(buffer, rtlMatch)) : seekNext(buffer, lastMatch);\n            }\n\n            function escapeRegex(str) {\n                var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n                return str.replace(new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'gim'), '\\\\$1');\n            }\n            function truncateInput(inputValue, rtl) {\n                return rtl ? inputValue.replace(new RegExp(\"^(\" + escapeRegex(_buffer.join('')) + \")*\"), \"\") : inputValue.replace(new RegExp(\"(\" + escapeRegex(_buffer.join('')) + \")*$\"), \"\");\n            }\n\n            function clearOptionalTail(input, buffer) {\n                checkVal(input, buffer, false);\n                var tmpBuffer = buffer.slice();\n                if ($(input).data('inputmask')['isRTL']) {\n                    for (var pos = 0; pos <= tmpBuffer.length - 1; pos++) {\n                        var testPos = determineTestPosition(pos);\n                        if (tests[testPos].optionality) {\n                            if (getPlaceHolder(pos) == buffer[pos] || !isMask(pos))\n                                tmpBuffer.splice(0, 1);\n                            else break;\n                        } else break;\n                    }\n                } else {\n                    for (var pos = tmpBuffer.length - 1; pos >= 0; pos--) {\n                        var testPos = determineTestPosition(pos);\n                        if (tests[testPos].optionality) {\n                            if (getPlaceHolder(pos) == buffer[pos] || !isMask(pos))\n                                tmpBuffer.pop();\n                            else break;\n                        } else break;\n                    }\n                }\n                writeBuffer(input, tmpBuffer);\n            }\n\n            //functionality fn\n            function unmaskedvalue($input, skipDatepickerCheck) {\n                var input = $input[0];\n                if (tests && (skipDatepickerCheck === true || !$input.hasClass('hasDatepicker'))) {\n                    var buffer = _buffer.slice();\n                    checkVal(input, buffer);\n                    return $.map(buffer, function (element, index) {\n                        return isMask(index) && element != getBufferElement(_buffer.slice(), index) ? element : null;\n                    }).join('');\n                }\n                else {\n                    return input._valueGet();\n                }\n            }\n\n            function caret(input, begin, end) {\n                var npt = input.jquery && input.length > 0 ? input[0] : input;\n                if (typeof begin == 'number') {\n                    end = (typeof end == 'number') ? end : begin;\n                    if (opts.insertMode == false && begin == end) end++; //set visualization for insert/overwrite mode\n                    if (npt.setSelectionRange) {\n                        npt.setSelectionRange(begin, end);\n                    } else if (npt.createTextRange) {\n                        var range = npt.createTextRange();\n                        range.collapse(true);\n                        range.moveEnd('character', end);\n                        range.moveStart('character', begin);\n                        range.select();\n                    }\n                    npt.focus();\n                    if (android && end != npt.selectionEnd) caretposCorrection = { begin: begin, end: end };\n                } else {\n                    var caretpos = android ? caretposCorrection : null, caretposCorrection = null;\n                    if (caretpos == null) {\n                        if (npt.setSelectionRange) {\n                            begin = npt.selectionStart;\n                            end = npt.selectionEnd;\n                        } else if (document.selection && document.selection.createRange) {\n                            var range = document.selection.createRange();\n                            begin = 0 - range.duplicate().moveStart('character', -100000);\n                            end = begin + range.text.length;\n                        }\n                        caretpos = { begin: begin, end: end };\n                    }\n                    return caretpos;\n                }\n            };\n\n            function mask(el) {\n                var $input = $(el);\n                if (!$input.is(\":input\")) return;\n\n                //correct greedy setting if needed\n                opts.greedy = opts.greedy ? opts.greedy : opts.repeat == 0;\n\n                //handle maxlength attribute\n                var maxLength = $input.prop('maxLength');\n                if (getMaskLength() > maxLength && maxLength > -1) { //FF sets no defined max length to -1 \n                    if (maxLength < _buffer.length) _buffer.length = maxLength;\n                    if (opts.greedy == false) {\n                        opts.repeat = Math.round(maxLength / _buffer.length);\n                    }\n                    $input.prop('maxLength', getMaskLength() * 2);\n                }\n\n                //store tests & original buffer in the input element - used to get the unmasked value\n                $input.data('inputmask', {\n                    'tests': tests,\n                    '_buffer': _buffer,\n                    'greedy': opts.greedy,\n                    'repeat': opts.repeat,\n                    'autoUnmask': opts.autoUnmask,\n                    'definitions': opts.definitions,\n                    'isRTL': false\n                });\n\n                patchValueProperty(el);\n\n                //init vars\n                var buffer = _buffer.slice(),\n                undoBuffer = el._valueGet(),\n                skipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround\n                ignorable = false,\n                lastPosition = -1,\n                firstMaskPos = seekNext(buffer, -1),\n                lastMaskPos = seekPrevious(buffer, getMaskLength()),\n                isRTL = false;\n                if (el.dir == \"rtl\" || opts.numericInput) {\n                    el.dir = \"ltr\"\n                    $input.css(\"text-align\", \"right\");\n                    $input.removeAttr(\"dir\");\n                    var inputData = $input.data('inputmask');\n                    inputData['isRTL'] = true;\n                    $input.data('inputmask', inputData);\n                    isRTL = true;\n                }\n\n                //unbind all events - to make sure that no other mask will interfere when re-masking\n                $input.unbind(\".inputmask\");\n                $input.removeClass('focus.inputmask');\n                //bind events\n                $input.bind(\"mouseenter.inputmask\", function () {\n                    var $input = $(this), input = this;\n                    if (!$input.hasClass('focus.inputmask') && opts.showMaskOnHover) {\n                        var nptL = input._valueGet().length;\n                        if (nptL < buffer.length) {\n                            if (nptL == 0)\n                                buffer = _buffer.slice();\n                            writeBuffer(input, buffer);\n                        }\n                    }\n                }).bind(\"blur.inputmask\", function () {\n                    var $input = $(this), input = this, nptValue = input._valueGet();\n                    $input.removeClass('focus.inputmask');\n                    if (nptValue != undoBuffer) {\n                        $input.change();\n                    }\n                    if (opts.clearMaskOnLostFocus) {\n                        if (nptValue == _buffer.join(''))\n                            input._valueSet('');\n                        else { //clearout optional tail of the mask\n                            clearOptionalTail(input, buffer);\n                        }\n                    }\n                    if (!isComplete(input)) {\n                        $input.trigger(\"incomplete\");\n                        if (opts.clearIncomplete) {\n                            if (opts.clearMaskOnLostFocus)\n                                input._valueSet('');\n                            else {\n                                buffer = _buffer.slice();\n                                writeBuffer(input, buffer);\n                            }\n                        }\n                    }\n                }).bind(\"focus.inputmask\", function () {\n                    var $input = $(this), input = this;\n                    if (!$input.hasClass('focus.inputmask') && !opts.showMaskOnHover) {\n                        var nptL = input._valueGet().length;\n                        if (nptL < buffer.length) {\n                            if (nptL == 0)\n                                buffer = _buffer.slice();\n                            caret(input, checkVal(input, buffer, true));\n                        }\n                    }\n                    $input.addClass('focus.inputmask');\n                    undoBuffer = input._valueGet();\n                }).bind(\"mouseleave.inputmask\", function () {\n                    var $input = $(this), input = this;\n                    if (opts.clearMaskOnLostFocus) {\n                        if (!$input.hasClass('focus.inputmask')) {\n                            if (input._valueGet() == _buffer.join('') || input._valueGet() == '')\n                                input._valueSet('');\n                            else { //clearout optional tail of the mask\n                                clearOptionalTail(input, buffer);\n                            }\n                        }\n                    }\n                }).bind(\"click.inputmask\", function () {\n                    var input = this;\n                    setTimeout(function () {\n                        var selectedCaret = caret(input);\n                        if (selectedCaret.begin == selectedCaret.end) {\n                            var clickPosition = selectedCaret.begin;\n                            lastPosition = checkVal(input, buffer, false);\n                            if (isRTL)\n                                caret(input, clickPosition > lastPosition && (isValid(clickPosition, buffer[clickPosition], buffer, true) !== false || !isMask(clickPosition)) ? clickPosition : lastPosition);\n                            else\n                                caret(input, clickPosition < lastPosition && (isValid(clickPosition, buffer[clickPosition], buffer, true) !== false || !isMask(clickPosition)) ? clickPosition : lastPosition);\n                        }\n                    }, 0);\n                }).bind('dblclick.inputmask', function () {\n                    var input = this;\n                    setTimeout(function () {\n                        caret(input, 0, lastPosition);\n                    }, 0);\n                }).bind(\"keydown.inputmask\", keydownEvent\n                ).bind(\"keypress.inputmask\", keypressEvent\n                ).bind(\"keyup.inputmask\", keyupEvent\n                ).bind(pasteEvent + \".inputmask, dragdrop.inputmask, drop.inputmask\", function () {\n                    var input = this;\n                    setTimeout(function () {\n                        caret(input, checkVal(input, buffer, true));\n                    }, 0);\n                }).bind('setvalue.inputmask', function () {\n                    var input = this;\n                    undoBuffer = input._valueGet();\n                    checkVal(input, buffer, true);\n                    if (input._valueGet() == _buffer.join(''))\n                        input._valueSet('');\n                }).bind('complete.inputmask', opts.oncomplete)\n                .bind('incomplete.inputmask', opts.onincomplete)\n                .bind('cleared.inputmask', opts.oncleared);\n\n                //apply mask\n                lastPosition = checkVal(el, buffer, true);\n\n                // Wrap document.activeElement in a try/catch block since IE9 throw \"Unspecified error\" if document.activeElement is undefined when we are in an IFrame.\n                var activeElement;\n                try {\n                    activeElement = document.activeElement;\n                } catch (e) { }\n                if (activeElement === el) { //position the caret when in focus\n                    $input.addClass('focus.inputmask');\n                    caret(el, lastPosition);\n                } else if (opts.clearMaskOnLostFocus) {\n                    if (el._valueGet() == _buffer.join('')) {\n                        el._valueSet('');\n                    } else {\n                        clearOptionalTail(el, buffer);\n                    }\n                }\n\n                installEventRuler(el);\n\n                //private functions\n                function isComplete(npt) {\n                    var complete = true, nptValue = npt._valueGet(), ml = nptValue.length;\n                    for (var i = 0; i < ml; i++) {\n                        if (isMask(i) && nptValue.charAt(i) == getPlaceHolder(i)) {\n                            complete = false;\n                            break;\n                        }\n                    }\n                    return complete;\n                }\n\n\n                function installEventRuler(npt) {\n                    var events = $._data(npt).events;\n\n                    $.each(events, function (eventType, eventHandlers) {\n                        $(npt).bind(eventType + \".inputmask\", function (event) {\n                            if (this.readOnly || this.disabled) {\n                                event.stopPropagation();\n                                event.stopImmediatePropagation();\n                                event.preventDefault();\n                                return false;\n                            }\n                        });\n                        //!! the bound handlers are executed in the order they where bound\n                        //reorder the events\n                        var ourHandler = eventHandlers[eventHandlers.length - 1];\n                        for (var i = eventHandlers.length - 1; i > 0; i--) {\n                            eventHandlers[i] = eventHandlers[i - 1];\n                        }\n                        eventHandlers[0] = ourHandler;\n                    });\n                }\n\n                function patchValueProperty(npt) {\n                    var valueProperty;\n                    if (Object.getOwnPropertyDescriptor)\n                        valueProperty = Object.getOwnPropertyDescriptor(npt, \"value\");\n                    if (valueProperty && valueProperty.get) {\n                        if (!npt._valueGet) {\n\n                            npt._valueGet = valueProperty.get;\n                            npt._valueSet = valueProperty.set;\n\n                            Object.defineProperty(npt, \"value\", {\n                                get: function () {\n                                    var $self = $(this), inputData = $(this).data('inputmask');\n                                    return inputData && inputData['autoUnmask'] ? $self.inputmask('unmaskedvalue') : this._valueGet() != inputData['_buffer'].join('') ? this._valueGet() : '';\n                                },\n                                set: function (value) {\n                                    this._valueSet(value); $(this).triggerHandler('setvalue.inputmask');\n                                }\n                            });\n                        }\n                    } else if (document.__lookupGetter__ && npt.__lookupGetter__(\"value\")) {\n                        if (!npt._valueGet) {\n                            npt._valueGet = npt.__lookupGetter__(\"value\");\n                            npt._valueSet = npt.__lookupSetter__(\"value\");\n\n                            npt.__defineGetter__(\"value\", function () {\n                                var $self = $(this), inputData = $(this).data('inputmask');\n                                return inputData && inputData['autoUnmask'] ? $self.inputmask('unmaskedvalue') : this._valueGet() != inputData['_buffer'].join('') ? this._valueGet() : '';\n                            });\n                            npt.__defineSetter__(\"value\", function (value) {\n                                this._valueSet(value); $(this).triggerHandler('setvalue.inputmask');\n                            });\n                        }\n                    } else {\n                        if (!npt._valueGet) {\n                            npt._valueGet = function () { return this.value; }\n                            npt._valueSet = function (value) { this.value = value; }\n                        }\n                        if ($.fn.val.inputmaskpatch != true) {\n                            $.fn.val = function () {\n                                if (arguments.length == 0) {\n                                    var $self = $(this);\n                                    if ($self.data('inputmask')) {\n                                        if ($self.data('inputmask')['autoUnmask'])\n                                            return $self.inputmask('unmaskedvalue');\n                                        else {\n                                            var result = $.inputmask.val.apply($self);\n                                            return result != $self.data('inputmask')['_buffer'].join('') ? result : '';\n                                        }\n                                    } else return $.inputmask.val.apply($self);\n                                } else {\n                                    var args = arguments;\n                                    return this.each(function () {\n                                        var $self = $(this);\n                                        var result = $.inputmask.val.apply($self, args);\n                                        if ($self.data('inputmask')) $self.triggerHandler('setvalue.inputmask');\n                                        return result;\n                                    });\n                                }\n                            };\n                            $.extend($.fn.val, {\n                                inputmaskpatch: true\n                            });\n                        }\n                    }\n                }\n                //shift chars to left from start to end and put c at end position if defined\n                function shiftL(start, end, c) {\n                    while (!isMask(start) && start - 1 >= 0) start--;\n                    for (var i = start; i < end && i < getMaskLength(); i++) {\n                        if (isMask(i)) {\n                            setReTargetPlaceHolder(buffer, i);\n                            var j = seekNext(buffer, i);\n                            var p = getBufferElement(buffer, j);\n                            if (p != getPlaceHolder(j)) {\n                                if (j < getMaskLength() && isValid(i, p, buffer, true) !== false && tests[determineTestPosition(i)].def == tests[determineTestPosition(j)].def) {\n                                    setBufferElement(buffer, i, getBufferElement(buffer, j));\n                                    setReTargetPlaceHolder(buffer, j); //cleanup next position\n                                } else {\n                                    if (isMask(i))\n                                        break;\n                                }\n                            } else if (c == undefined) break;\n                        } else {\n                            setReTargetPlaceHolder(buffer, i);\n                        }\n                    }\n                    if (c != undefined)\n                        setBufferElement(buffer, isRTL ? end : seekPrevious(buffer, end), c);\n\n                    buffer = truncateInput(buffer.join(''), isRTL).split('');\n                    if (buffer.length == 0) buffer = _buffer.slice();\n\n                    return start; //return the used start position\n                }\n                function shiftR(start, end, c, full) { //full => behave like a push right ~ do not stop on placeholders\n                    for (var i = start; i <= end && i < getMaskLength(); i++) {\n                        if (isMask(i)) {\n                            var t = getBufferElement(buffer, i);\n                            setBufferElement(buffer, i, c);\n                            if (t != getPlaceHolder(i)) {\n                                var j = seekNext(buffer, i);\n                                if (j < getMaskLength()) {\n                                    if (isValid(j, t, buffer, true) !== false && tests[determineTestPosition(i)].def == tests[determineTestPosition(j)].def)\n                                        c = t;\n                                    else {\n                                        if (isMask(j))\n                                            break;\n                                        else c = t;\n                                    }\n                                } else break;\n                            } else if (full !== true) break;\n                        } else\n                            setReTargetPlaceHolder(buffer, i);\n                    }\n                    var lengthBefore = buffer.length;\n                    buffer = truncateInput(buffer.join(''), isRTL).split('');\n                    if (buffer.length == 0) buffer = _buffer.slice();\n\n                    return end - (lengthBefore - buffer.length);  //return new start position\n                };\n\n                function keydownEvent(e) {\n                    //Safari 5.1.x - modal dialog fires keypress twice workaround\n                    skipKeyPressEvent = false;\n\n                    var input = this, k = e.keyCode, pos = caret(input);\n\n                    //set input direction according the position to the radixPoint\n                    if (opts.numericInput) {\n                        var nptStr = input._valueGet();\n                        var radixPosition = nptStr.indexOf(opts.radixPoint);\n                        if (radixPosition != -1) {\n                            isRTL = pos.begin <= radixPosition || pos.end <= radixPosition;\n                        }\n                    }\n\n                    //backspace, delete, and escape get special treatment\n                    if (k == opts.keyCode.BACKSPACE || k == opts.keyCode.DELETE || (iphone && k == 127)) {//backspace/delete\n                        var maskL = getMaskLength();\n                        if (pos.begin == 0 && pos.end == maskL) {\n                            buffer = _buffer.slice();\n                            writeBuffer(input, buffer);\n                            caret(input, checkVal(input, buffer, false));\n                        } else if ((pos.end - pos.begin) > 1 || ((pos.end - pos.begin) == 1 && opts.insertMode)) {\n                            clearBuffer(buffer, pos.begin, pos.end);\n                            writeBuffer(input, buffer, isRTL ? checkVal(input, buffer, false) : pos.begin);\n                        } else {\n                            var beginPos = pos.begin - (k == opts.keyCode.DELETE ? 0 : 1);\n                            if (beginPos < firstMaskPos && k == opts.keyCode.DELETE) {\n                                beginPos = firstMaskPos;\n                            }\n                            if (beginPos >= firstMaskPos) {\n                                if (opts.numericInput && opts.greedy && k == opts.keyCode.DELETE && buffer[beginPos] == opts.radixPoint) {\n                                    beginPos = seekNext(buffer, beginPos);\n                                    isRTL = false;\n                                }\n                                if (isRTL) {\n                                    beginPos = shiftR(firstMaskPos, beginPos, getPlaceHolder(beginPos), true);\n                                    beginPos = (opts.numericInput && opts.greedy && k == opts.keyCode.BACKSPACE && buffer[beginPos + 1] == opts.radixPoint) ? beginPos + 1 : seekNext(buffer, beginPos);\n                                } else beginPos = shiftL(beginPos, maskL);\n                                writeBuffer(input, buffer, beginPos);\n                            }\n                        }\n                        if (input._valueGet() == _buffer.join(''))\n                            $(input).trigger('cleared');\n\n                        return false;\n                    } else if (k == opts.keyCode.END || k == opts.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch\n                        setTimeout(function () {\n                            var caretPos = checkVal(input, buffer, false, true);\n                            if (!opts.insertMode && caretPos == getMaskLength() && !e.shiftKey) caretPos--;\n                            caret(input, e.shiftKey ? pos.begin : caretPos, caretPos);\n                        }, 0);\n                        return false;\n                    } else if (k == opts.keyCode.HOME || k == opts.keyCode.PAGE_UP) {//Home or page_up\n                        caret(input, 0, e.shiftKey ? pos.begin : 0);\n                        return false;\n                    }\n                    else if (k == opts.keyCode.ESCAPE) {//escape\n                        input._valueSet(undoBuffer);\n                        caret(input, 0, checkVal(input, buffer));\n                        return false;\n                    } else if (k == opts.keyCode.INSERT) {//insert\n                        opts.insertMode = !opts.insertMode;\n                        caret(input, !opts.insertMode && pos.begin == getMaskLength() ? pos.begin - 1 : pos.begin);\n                        return false;\n                    } else if (e.ctrlKey && k == 88) {\n                        setTimeout(function () {\n                            caret(input, checkVal(input, buffer, true));\n                        }, 0);\n                    } else if (!opts.insertMode) { //overwritemode\n                        if (k == opts.keyCode.RIGHT) {//right\n                            var caretPos = pos.begin == pos.end ? pos.end + 1 : pos.end;\n                            caretPos = caretPos < getMaskLength() ? caretPos : pos.end;\n                            caret(input, e.shiftKey ? pos.begin : caretPos, e.shiftKey ? caretPos + 1 : caretPos);\n                            return false;\n                        } else if (k == opts.keyCode.LEFT) {//left\n                            var caretPos = pos.begin - 1;\n                            caretPos = caretPos > 0 ? caretPos : 0;\n                            caret(input, caretPos, e.shiftKey ? pos.end : caretPos);\n                            return false;\n                        }\n                    }\n\n                    opts.onKeyDown.call(this, e, opts); //extra stuff to execute on keydown\n                    ignorable = $.inArray(k, opts.ignorables) != -1;\n                }\n\n                function keypressEvent(e) {\n                    //Safari 5.1.x - modal dialog fires keypress twice workaround\n                    if (skipKeyPressEvent) return false;\n                    skipKeyPressEvent = true;\n\n                    var input = this, $input = $(input);\n\n                    e = e || window.event;\n                    var k = e.which || e.charCode || e.keyCode;\n\n                    if (opts.numericInput && k == opts.radixPoint.charCodeAt(opts.radixPoint.length - 1)) {\n                        var nptStr = input._valueGet();\n                        var radixPosition = nptStr.indexOf(opts.radixPoint);\n                        caret(input, seekNext(buffer, radixPosition != -1 ? radixPosition : getMaskLength()));\n                    }\n\n                    if (e.ctrlKey || e.altKey || e.metaKey || ignorable) {//Ignore\n                        return true;\n                    } else {\n                        if (k) {\n                            $input.trigger('input');\n\n                            var pos = caret(input), c = String.fromCharCode(k), maskL = getMaskLength();\n                            clearBuffer(buffer, pos.begin, pos.end);\n\n                            if (isRTL) {\n                                var p = opts.numericInput ? pos.end : seekPrevious(buffer, pos.end), np;\n                                if ((np = isValid(p == maskL || getBufferElement(buffer, p) == opts.radixPoint ? seekPrevious(buffer, p) : p, c, buffer, false)) !== false) {\n                                    if (np !== true) {\n                                        p = np.pos || pos; //set new position from isValid\n                                        c = np.c || c; //set new char from isValid\n                                    }\n\n                                    var firstUnmaskedPosition = firstMaskPos;\n                                    if (opts.insertMode == true) {\n                                        if (opts.greedy == true) {\n                                            var bfrClone = buffer.slice();\n                                            while (getBufferElement(bfrClone, firstUnmaskedPosition, true) != getPlaceHolder(firstUnmaskedPosition) && firstUnmaskedPosition <= p) {\n                                                firstUnmaskedPosition = firstUnmaskedPosition == maskL ? (maskL + 1) : seekNext(buffer, firstUnmaskedPosition);\n                                            }\n                                        }\n\n                                        if (firstUnmaskedPosition <= p && (opts.greedy || buffer.length < maskL)) {\n                                            if (buffer[firstMaskPos] != getPlaceHolder(firstMaskPos) && buffer.length < maskL) {\n                                                var offset = prepareBuffer(buffer, -1, isRTL);\n                                                if (pos.end != 0) p = p + offset;\n                                                maskL = buffer.length;\n                                            }\n                                            shiftL(firstUnmaskedPosition, opts.numericInput ? seekPrevious(buffer, p) : p, c);\n                                        } else return false;\n                                    } else setBufferElement(buffer, opts.numericInput ? seekPrevious(buffer, p) : p, c);\n                                    writeBuffer(input, buffer, opts.numericInput && p == 0 ? seekNext(buffer, p) : p);\n                                    setTimeout(function () { //timeout needed for IE\n                                        if (isComplete(input))\n                                            $input.trigger(\"complete\");\n                                    }, 0);\n                                } else if (android) writeBuffer(input, buffer, pos.begin);\n                            }\n                            else {\n                                var p = seekNext(buffer, pos.begin - 1), np;\n                                prepareBuffer(buffer, p, isRTL);\n                                if ((np = isValid(p, c, buffer, false)) !== false) {\n                                    if (np !== true) {\n                                        p = np.pos || p; //set new position from isValid\n                                        c = np.c || c; //set new char from isValid\n                                    }\n                                    if (opts.insertMode == true) {\n                                        var lastUnmaskedPosition = getMaskLength();\n                                        var bfrClone = buffer.slice();\n                                        while (getBufferElement(bfrClone, lastUnmaskedPosition, true) != getPlaceHolder(lastUnmaskedPosition) && lastUnmaskedPosition >= p) {\n                                            lastUnmaskedPosition = lastUnmaskedPosition == 0 ? -1 : seekPrevious(buffer, lastUnmaskedPosition);\n                                        }\n                                        if (lastUnmaskedPosition >= p)\n                                            shiftR(p, buffer.length, c);\n                                        else return false;\n                                    }\n                                    else setBufferElement(buffer, p, c);\n                                    var next = seekNext(buffer, p);\n                                    writeBuffer(input, buffer, next);\n\n                                    setTimeout(function () { //timeout needed for IE\n                                        if (isComplete(input))\n                                            $input.trigger(\"complete\");\n                                    }, 0);\n                                } else if (android) writeBuffer(input, buffer, pos.begin);\n                            }\n                            return false;\n                        }\n                    }\n                }\n\n                function keyupEvent(e) {\n                    var $input = $(this), input = this;\n                    var k = e.keyCode;\n                    opts.onKeyUp.call(this, e, opts); //extra stuff to execute on keyup\n                    if (k == opts.keyCode.TAB && $input.hasClass('focus.inputmask') && input._valueGet().length == 0) {\n                        buffer = _buffer.slice();\n                        writeBuffer(input, buffer);\n                        if (!isRTL) caret(input, 0);\n                        undoBuffer = input._valueGet();\n                    }\n                }\n            }\n\n            return this; //return this to expose publics\n        };\n    }\n})(jQuery);\n"]}